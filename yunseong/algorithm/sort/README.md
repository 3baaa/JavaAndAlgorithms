
# 🏁 정렬
    💡 정렬은 핵심항목의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업을 말합니다.
---

:: ☝🏻INDEX ::

[1. 개념 및 용어](#개념-및-용어)</br>
[2. 정렬종류](#정렬종류)</br>

---

# 개념 및 용어

#### 📌 <u>정렬알고리즘의 안정성</u>
- 안정된 정렬이란 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것 입니다.
- 안정되지 않은 정렬은 하나의 키 값만을 갖고 정렬을 합니다.
#### 📌 <u>내부정렬과 외부정렬</u>
- 하나의 배열에서 작업할 수 있는 경우에는 내부정렬
- 여러 배열에서 작업하는 경우는 외부정렬
- 외부정렬은 내부정렬을 응용한 것으로, 작업을 위한 파일 등이 필요하고 알고리즘도 복잡합니다.
#### 📌 <u>정렬알고리즘의 핵심요소</u>
- 정렬 알고리즘의 핵심요소는 교환, 선택, 삽입이며 대부분의 정렬 알고리즘은 이 세가지 소스를 응용한 것 입니다.

#### 📌 시간복잡도와 BigO표기법
- **시간복잡도**❓ 입력값의 변화에 따라 얼만큼 시간이 걸리는지에 대한 정도
- **BigO표기법**❓ 시간복잡도를 나타내는 방법<br>

**:: 시간복잡도 표 ::**</br>

|  시간/n   |  1  |  2  |  3   |  4   |   8   |        16         |          32           |           64           |          1000          |
|:-------:|:---:|:---:|:----:|:----:|:-----:|:-----------------:|:---------------------:|:----------------------:|:----------------------:|
|    1    |  1  |  1  |  1   |  1   |   1   |         1         |           1           |           1            |           1            |
|  log n  |  0  |  1  | 1.58 |  2   |   3   |         4         |           5           |           6            |          9.97          |
|    n    |  1  |  2  |  3   |  4   |   8   |        16         |          32           |           64           |          1000          |
| n log n |  0  |  2  | 4.75 |  8   |  24   |        64         |          160          |          384           |          9966          |
|   n^2   |  1  |  4  |  9   |  16  |  64   |        256        |         1024          |          4096          |        1000000         |
|   n^3   |  1  |  8  |  27  |  64  |  512  |       4096        |         32768         |         262144         |       1000000000       |
|   2^n   |  2  |  4  |  8   |  16  |  256  |       65536       |      4294967296       |        약 1844경         |     약 1.07 x 10301     |
|   n!    |  1  |  2  |  6   |  24  | 40320 |  20922789888000   |     약 2.63 x 1035     |     약 1.27 x 1089      |    약 4.02 x 102567     |

---
# 🤓 정렬종류

---

## 📌 버블정렬
<details>
<summary>:: 👀 학습내용 확인하기 :: </summary>
<div markdown="1">

- 단순하기 때문에 자주사용된다
- 원소의 이동이 거품이 수면으로 올라오는 듯한 모습
- O(n^2)
- 방법
  1. 서로 인접한 두원소 크기를 검사한다.
  2. 인접한 두수를 계속 비교해 가장 큰 자료가 맨뒤로 가도록 한다.



</div>
</details>

## 📌 단순선택정렬
<details>
<summary>:: 👀 학습내용 확인하기 :: </summary>
<div markdown="1">

- 제자리정렬 알고리즘
- 단순하게 사용할 수 있다.
- 메모리 효율이 좋다
- O(n^2)
- 방법
    1. 주어진 리스트 중 최소값을 찾는다</br>
    2. 그 값을 맨앞의 위치한 값과 교체
    3. 맨처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체
</div>
</details>

## 📌 단순삽입정렬

<details>
<summary>:: 👀 학습내용 확인하기 :: </summary>
<div markdown="1">

- 데이터를 **비교**하면서 찾기 때문에 **비교정렬**이라고 합니다.
- 삽입 정렬은 두 번째 자료부터 시작하여 그 앞의 자료들과 비교하여 삽입할 위치를 지정한 후 
  </br>자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.
-  최선 : O(N), 최악 : O(n^2)
</div>
</details>

## 📌 셸정렬

<details>
<summary>:: 👀 학습내용 확인하기 :: </summary>
<div markdown="1">

- 셸 정렬은 **삽입 정렬**을 기반으로 한다
- 정렬의 대상이 되는 데이터 외에 추가적인 공간을 필요로 하지 않기 때문에 **'제자리 정렬(in-place sort)'** 이기도 하다.
- 삽입정렬과는 다르게 일정 간격을 주기로 하여 비교 및 교환이 일어나기 때문에 구조상 **안정정렬(Stable Sort)은 아니다.**
-  최선 : O(N), 최악 : O(n^2)
- 방법
  1. 간격(gap)을 설정한다.
  2. 각 간격별로 분류 된 서브(부분) 리스트에 대해 삽입정렬을 한다.
  3. 각 서브(부분) 리스트의 정렬이 끝나면 간격을 줄인다.
  4. 간격이 1이 될 때 까지 2번 과정으로 되돌아가며 반복한다.

</div>
</details>

## 📌 퀵정렬

<details>
<summary>:: 👀 학습내용 확인하기 :: </summary>
<div markdown="1">

- 퀵 정렬은 **불안정정렬** 에 속하며, 다른 원소와의 비교만으로 정렬을 수행하는 **비교정렬** 에 속한다.
- **분할 정복 알고리즘**의 하나로, 평균적으로 **매우 빠른** 수행 속도
- 합병 정렬(merge sort)과 달리 퀵 정렬은 리스트를 **비균등**하게 분할한다.
- O(nlogn)
- 방법
  1. 리스트 안에 있는 한 요소를 선택한다. 이렇게 고른 원소를 피벗(pivot) 이라고 한다.
  2. 피벗을 기준으로 피벗보다 작은 요소들은 모두 피벗의 왼쪽으로 옮겨지고 피벗보다 큰 요소들은 모두 피벗의 오른쪽으로 옮겨진다.
  </br> (피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)
  3. 피벗을 제외한 왼쪽 리스트와 오른쪽 리스트를 다시 정렬한다.
     - 분할된 부분 리스트에 대하여 순환 호출 을 이용하여 정렬을 반복한다.
     - 부분 리스트에서도 다시 피벗을 정하고 피벗을 기준으로 2개의 부분 리스트로 나누는 과정을 반복한다.
  4. 부분 리스트들이 더 이상 분할이 불가능할 때까지 반복한다.
     - 리스트의 크기가 0이나 1이 될 때까지 반복한다.
  
</div>
</details>

## 📌 힙정렬

<details>
<summary>:: 👀 학습내용 확인하기 :: </summary>
<div markdown="1">

- 최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방법
- 내림차순 정렬을 위해서는 최대 힙을 구성하고 오름차순 정렬을 위해서는 최소 힙을 구성하면 된다.
- O(nlogn)
- 방법
  1. 정렬해야 할 n개의 요소들로 최대 힙(완전 이진 트리 형태)을 만든다.
     - 내림차순을 기준으로 정렬
  2. 그 다음으로 한 번에 하나씩 요소를 힙에서 꺼내서 배열의 뒤부터 저장하면 된다.
  3. 삭제되는 요소들(최댓값부터 삭제)은 값이 감소되는 순서로 정렬되게 된다.
     
</div>
</details>