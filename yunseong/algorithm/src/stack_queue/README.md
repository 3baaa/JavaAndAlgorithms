# 스택&큐

[1. 개념](#개념)</br>
[2. 문제링크](#문제링크)</br>
[3. 프로그래머스 레벨2 주식가격](#프로그래머스-레벨2-주식가격)</br>
[4. 프로그래머스 레벨2 다리를 지나는 트럭](#프로그래머스-레벨2-다리를-지나는-트럭)</br>
[5. 백준1874 스택수열](#백준1874-스택수열)</br>
[6. 백준5397 키로거](#백준5397-키로거)</br>
[7. 백준4949 균형잡힌세상](#백준4949-균형잡힌세상)</br>

---
## 개념
> 💡자료구조는 데이터를 보다 효율적으로 다루기 위한 구조를 의미합니다.</br>
표준화된 클래스들을 제공해주기 때문에 구조를 구현하지 않고도 편하게 사용할 수 있습니다.</br>
>>- Stack&Queue는 Collection의 대표적인 예 입니다.</br>
>>- 이외에 List, Map, Set 인터페이스를 기준으로 여러 구현체가 존재합니다. </br>

> 💡Stack is LIFO(Last In First Out)
>> method
>>> 1. pop(): 스택에서 가장 위에 있는 항목을 제거한다.
>>> 2. push(item): item 하나를 스택의 가장 윗 부분에 추가한다.
>>> 3. peek(): 스택의 가장 위에 있는 항목을 반환한다.
>>> 4. isEmpty(): 스택이 비어 있을 때에 true를 반환한다.

> 💡Queue is FIFO(First In First Out)
>> method
>>> 1. poll(): 큐에서 가장 앞에 있는 항목을 제거한다.
>>> 2. add(item): item 하나를 큐의 가장 마지막 부분에 추가한다.
>>> 3. peek(): 큐의 가장 밑에 있는 항목을 반환한다.
>>> 4. isEmpty() : 큐가 비어있을 때에 true를 반환한다.
---
## 문제링크
> [주식가격](https://programmers.co.kr/learn/courses/30/lessons/42584)</br>
> [다리를지나는트럭](https://programmers.co.kr/learn/courses/30/lessons/42583)</br>
> [스택수열](https://www.acmicpc.net/problem/1874)</br>
---
## 프로그래머스 레벨2 주식가격

> 배열에 주식가격이 담겨져서 주어진다. 인덱스 하나차이를 1초차이라고 가정한다. 그리고 첫 번째 인덱스부터 몇초동안 안떨어지는지 계산하는 문제이다. 
>>1. 스택에는 인덱스를 넣어준다.
>>2. 주식가격 배열의 순번은 스택의 순번보다 하나 앞서나가게 됩니다.
>>3. 스택의 순번과 배열의 순번을 비교해줍니다. 스택의 순번이 더크면 가격이 떨어졌다는 뜻입니다.
>>4. 그러면 해당 순번과 스택순번과의 차이를 답 배열에 넣어줍니다.
>>5. 그렇게 스택순번을 pop()하고 그 스택과 2,3,4번 과정을 반복합니다.
>>6. 그리고 가격이 떨어지지 않은 순번은 끝까지 가격이 안떨어진 것이기 때문에 꺼내서 계산해주면 끝!
---
## 프로그래머스 레벨2 다리를 지나는 트럭

> 💡 어렵진 않았지만, 코드를 간단하게 하는 과정이 좀 걸렸습니다. 제약조건들을 풀어가는 과정이 유의미 했습니다.


> 제약조건이 몇가지가 있습니다만, 침착하게 하나씩 제약조건을 걸어가면서 풀면 문제 접근이 쉬웠습니다.
>>1. 다리가 견딜 수 있는 하중을 생각해줘야합니다.
>>2. 다리를 건너려면 다리의 길이만큼 시간이 소요됩니다.(ex.다리길이 : 2 == 2초)
>>3. 다리길이보다 트럭이 많이 올라갈 수 없습니다.
>>4. 트럭이 다리에서 빠지는 동시에 새로운것이 들어와야합니다.
>>>큐를 활용하여 문제를 풉니다.
>>>다리에 올라간 트럭과 들어올 트럭의 합이 다리하중보다 작으면 큐에 넣어줍니다.
>>>다리하중보다 트럭들의 무게가 크다면 큐에 0을 넣어줍니다.
>>>그리고 1초씩 올려줍니다.
>>>큐가 다리길이와 같아지면 다리끝에 도착한것이니 다리에 올라간 트럭 즉, 큐에서 poll()을 해줍니다.
>>>그리고 이것을 다리에 올라간 총 트럭의 무게에서 빼줍니다.
>>>반복하면 마지막 트럭이 들어왔을때 반복문이 끝납니다. 
>>>따라서 +다리길이를 해주면 문제 해결입니다.
``` java
  for(int i = 0 ; i < truck_weights.length ;) { 
              if(bridge.size() < bridge_length) {
                  if(weight >= sum + truck_weights[i]) {// 다리하중 > 트럭 총 무게 + 들어올트럭
                      bridge.add(truck_weights[i]); //큐에 트럭 넣어줍니다.
                      sum += truck_weights[i];//트럭총무게에 트럭을 더해줍니다.
                      i++; //다음 트럭
                  }else {
                      bridge.add(0);//다리하중이 더작으면 0을 넣어줍니다. 
                  }
                  answer++;//어떤경우에도 한회 당 1초씩 증가합니다.
              }else sum -= bridge.poll(); 	
              //트럭이 빠짐과 동시에 들어와야하기 때문에 빠지는 작업은 초를 증가시켜주지 않습니다. 
          }
          return answer+bridge_length;//마지막 트럭이 들어오면 반복문이 끝납니다. 
          //따라서 다리길이만큼 소요시간이 늘어납니다.
      }

```
---
## 백준1874 스택수열

>💡 배열과 스택에 대한 이해 그리고 반복문을 활용할 줄 안다면 쉽게 접근할 수 있을 것입니다. 
데이터가 저장되는 값들은 눈에 보이지 않기 때문에 어느 영역에 어떤 형태로 저장되는지 확실히 이해하는 것이 속도향상에 도움이 될 것 입니다.

> 배열에는 1 ~ n까지의 무작위 수열이 들어갑니다.
> 스택에는 1 ~ n까지의 숫자가 들어갑니다.
>> 1. 배열의 첫 인덱스값이 나올때까지 스택에 1부터 넣어줍니다.
>> 2. 배열의 첫인덱스 값이 스택에서 발견 됐습니다. ➡️ 결과에 '+' 문자를 넣어줍니다.
>> 3. 스택에서 팝을 해줍니다. ➡️ 결과에 '-' 문자를 넣어줍니다.
>> 4. 스택이 비었다면 결과를 출력해주고, 스택이 비지 않았다면 NO를 출력해줍니다.
``` java 
		int j = 1; //스택에 들어갈 값 1~5
		for (int i = 0; i < n; i++) {
			if(stack.isEmpty()) {//스택이 비어있으면 추가해줍니다.
				stack.push(j++);//1들어가고 후위연산
				list.add('+');
			}
            //인덱스의 값이 스택의 수와 같지 않으면 계속 후위연산하면서 넣어줍니다.
			while(stack.size() < n && stack.peek()!=origin[i]) {			
				stack.push(j++);//2들어가고 후위연산
				list.add('+');
			}
            //인덱스의 값이 스택의 수와 같게 되면 스택에서 꺼내 줍니다. 그리고 반복
			if(!stack.isEmpty()&&stack.peek()==origin[i]) {
				stack.pop();
				list.add('-');				
			}
		}

```
---
## 백준5397 키로거 

> 💡 '<', '>', '-'에 따라서 문자열의 배열을 수정해주면 되는 문제입니다.</br>
> 각 경우에 따라 어떻게 문자를 수정할지 고민하면 문제 접근은 쉽게 할 수 있습니다.
> 예외의 상황을 잘 점검해줘야 합니다.
>> 1. 주어진 문자열을 한 문자씩 받아옵니다.
>> 2. 문자가 '<', '>', '-' 이 아니라면 답 스택에  문자를 담아줍니다.
>> 3. 문자가 '<'라면 예비 스택에 답스택의 문자를 pop() 해서 넣어줍니다.
>>> 📌 커서가 왼쪽으로 이동한다 ➡️ 일단 해당 문자를 예비 스택으로 뺴놓는다. 
>> 4. 문자가 '>'라면 답 스택에 예비스택의 문자를 pop() 해서 넣어줍니다.
>>> 📌  커서가 오른쪽으로 이동한다. ➡️ 예비스택에 있던 문자를 갖고 온다.
>> 5. 문자가 '-'라면 답 스택에서 문자를 pop() 해줍니다.
>> 6. 예비 스택에 남은 문자를 모두 답스택에 넣어줍니다.
>> 7. StringBuilder를 활용해 답 스택의 문자를 담아준뒤 reverse() 함수를 이용해 답을 출력합니다.

---

## 백준4949 균형잡힌세상

> 출력의 형태라든지, .찍으면 끝이 난다든지 하는 부분이 애매해서 혜맸다.</br>
>  로직을 짜는 과정까지는 수월하게 갔지만, 중간에 조건을 하나 놓치는 바람에 시간이 꽤 걸렸다.</br>
>>1. 문자열을 하나씩 검사하면서 괄호를 만날때 마다 조건을 걸어줘야 한다.
>>2. 스택이 비어있을 경우 
>>> 2-1. ')', ']'의 닫힘 괄호를 만나면 무조건 break; ➡️ No출력</br>
>>> 2-2. 이외에는 스택에 괄호를 넣어준다.
>> 3. 스택이 비어있지 않을 경우
>>> 3-1. 스택의 열림 괄호 '(', ']' 일 경우
>>>> 3-1-1. 문자가 짝이 맞는 닫힘괄호 시 스택에서 pop(); ex) ( ), [ ]
>>>> 3-1-2. 문자가 열림괄호 시 스택에 괄호 추가 ex) ((([[ </br>
>>>> 3-1-3. 문자가 짝이 다른 닫힘괄호 시 ex) ( ], [ )</br>
>>4. 그렇게 짝이 맞는 괄호를 다하면 스택에 괄호가 없을 것</br>
>>5. 스택이 비었다면 yes출력 아니면 no를 출력하면 된다.
>>📌 중요 : 여러 문자열을 받아야해서 매번 stack.clear()를 해줘서 스택을 비워줘야한다!!










